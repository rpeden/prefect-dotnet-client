/*
 * Prefect API Client for .NET
 *
 * For more information, visit: https://github.com/rpeden/prefect-client-dotnet
 *
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = PrefectClient.Client.FileParameter;
using OpenAPIDateConverter = PrefectClient.Client.OpenAPIDateConverter;

namespace PrefectClient.Model
{
    /// <summary>
    /// A schedule formed by adding `interval` increments to an `anchor_date`. If no\\n`anchor_date` is supplied, the current UTC time is used.  If a\\ntimezone-naive datetime is provided for `anchor_date`, it is assumed to be\\nin the schedule's timezone (or UTC). Even if supplied with an IANA timezone,\\nanchor dates are always stored as UTC offsets, so a `timezone` can be\\nprovided to determine localization behaviors like DST boundary handling. If\\nnone is provided it will be inferred from the anchor date.\\n\\nNOTE: If the `IntervalSchedule` `anchor_date` or `timezone` is provided in a\\nDST-observing timezone, then the schedule will adjust itself appropriately.\\nIntervals greater than 24 hours will follow DST conventions, while intervals\\nof less than 24 hours will follow UTC intervals. For example, an hourly\\nschedule will fire every UTC hour, even across DST boundaries. When clocks\\nare set back, this will result in two runs that *appear* to both be\\nscheduled for 1am local time, even though they are an hour apart in UTC\\ntime. For longer intervals, like a daily schedule, the interval schedule\\nwill adjust for DST boundaries so that the clock-hour remains constant. This\\nmeans that a daily schedule that always fires at 9am will observe DST and\\ncontinue to fire at 9am in the local time zone.\\n\\nArgs:\\n    interval (datetime.timedelta): an interval to schedule on\\n    anchor_date (DateTimeTZ, optional): an anchor date to schedule increments against;\\n        if not provided, the current timestamp will be used\\n    timezone (str, optional): a valid timezone string
    /// </summary>
    [DataContract(Name = "IntervalSchedule")]
    public partial class IntervalSchedule : IEquatable<IntervalSchedule>, IValidatableObject
    {
                /// <summary>
        /// Initializes a new instance of the <see cref="IntervalSchedule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected IntervalSchedule() { }
        

        /// <summary>
        /// Gets or Sets Interval
        /// </summary>
        [DataMember(Name = "interval", IsRequired = true, EmitDefaultValue = true)]
        public decimal? Interval { get; set; }

        /// <summary>
        /// Gets or Sets AnchorDate
        /// </summary>
        [DataMember(Name = "anchor_date", EmitDefaultValue = false)]
        public DateTime? AnchorDate { get; set; }

        /// <summary>
        /// Gets or Sets Timezone
        /// </summary>
        /// <example>America/New_York</example>
        [DataMember(Name = "timezone", EmitDefaultValue = false)]
        public string? Timezone { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class IntervalSchedule {\n");
            sb.Append("  Interval: ").Append(Interval).Append("\n");
            sb.Append("  AnchorDate: ").Append(AnchorDate).Append("\n");
            sb.Append("  Timezone: ").Append(Timezone).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as IntervalSchedule);
        }

        /// <summary>
        /// Returns true if IntervalSchedule instances are equal
        /// </summary>
        /// <param name="input">Instance of IntervalSchedule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(IntervalSchedule input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Interval == input.Interval ||
                    this.Interval.Equals(input.Interval)
                ) && 
                (
                    this.AnchorDate == input.AnchorDate ||
                    (this.AnchorDate != null &&
                    this.AnchorDate.Equals(input.AnchorDate))
                ) && 
                (
                    this.Timezone == input.Timezone ||
                    (this.Timezone != null &&
                    this.Timezone.Equals(input.Timezone))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Interval.GetHashCode();
                if (this.AnchorDate != null)
                {
                    hashCode = (hashCode * 59) + this.AnchorDate.GetHashCode();
                }
                if (this.Timezone != null)
                {
                    hashCode = (hashCode * 59) + this.Timezone.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
